# A custom Library that can parse and evaluate Mathematical functions accepted as strings  

Aim is to write a number of functions that can do a number of things:  

* Lexer-> Tokenizes the string and stores the tokens in a linked list sequenced according to the 
 corresponding tokens in the input string.  
* rpnArrayParser-> Parses the token list and generates a dynamic array of tokens arranged according
to the Reverse Polish Notation.  
* rpnASTparser-> Parses the token list and generates an Abstract Syntax Tree of tokens.  
* rpnArrayEval-> Evaluates the RPN Array generated by rpnArrayParser and returns a decimal value.  
* rpnASTeval-> Evaluates the Abstract Syntax Tree generated by rpnASTparser and returns a decimal value.  
  
Each of the above functions can be used independently with the appropriate headers defined. 


| Lexer | 
---------
token *lex(char *inputString);  
-
The Lexer recognizes 4 different kinds of Tokens:  
  * Variable 'x'  
  * Decimal numerals
  * Parantheses
  * Elementary functions (sin, cos, ln, etc)


| rpnArrayParser |  
------------------
Stack *parser(token *linkedlistHead);  
-
The parser scans through the linked list of lexical tokens generated by our lexer and
derives a dynamic array of elements arranged in Reverse Polish Notation (postfix nota
tion).  

The shunting yard algorithm is employed to achieve this task.  


| rpnArrayEval |
----------------


A very simple recursive algorithm though memory heavy and slow.  
> Sequentially Scan across the received Array of tokens.  
                             +-----------------------------+    +-------------------+  
> If a sub-array of the form |operand | operand | operator | or |operand | function | is found,evaluate,    
                             +-----------------------------+    +-------------------+  
  store in a token of type numeral. Push the token into stackA.  

> In case three elements don't form the defined subarray, simply push consecutively.  
  
> Repeat steps 2-3 untill all tokens have been scanned.  
  
> Use stackA as the new Array of tokens and repeat steps 1-3 but using stackB for the intended purpose  
  of stackA in step 2.  

> Empty stackA ans repeat steps 1-5 untill the stack has a single element. !!

  


